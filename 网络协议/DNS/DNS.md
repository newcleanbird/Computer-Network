# DNS

DNS（Domain Name System，域名系统）协议是**应用层协议**。在OSI（Open Systems Interconnection）七层模型中，应用层是最高层，负责处理特定的应用程序细节。DNS位于这一层，因为它提供了一个应用程序级别的服务，即域名解析服务，允许将人类可读的域名转换为计算机网络使用的IP地址。

DNS协议的功能包括：

- 解析域名到IP地址。
- 提供反向解析，即将IP地址转换回域名。
- 支持邮件服务器查找（MX记录）。
- 提供其他与域名相关的查询，如主机信息（TXT记录）。

DNS使用UDP协议在端口53上进行大多数的查询和响应，尽管对于较大的响应或者需要更高可靠性的交互，DNS也支持使用TCP协议。

应用层协议还包括HTTP（超文本传输协议）、FTP（文件传输协议）、SMTP（简单邮件传输协议）等，它们都在OSI模型的同一层，为用户提供特定的网络服务。

## DNS的定义及基本概念

### 什么是DNS？

DNS（Domain Name System） 是⼀种⽤于将域名（例如 `www.baidu.com`）转换为IP地址（例如 `220.181.111.188` ）的分布式系统。在互联⽹上，计算机和其他⽹络设备使⽤IP地址来相互识别和通信。然⽽，IP地址是⼀串数字，不太⽅便⼈们使⽤和记忆，所以就使⽤了域名来代替复杂的IP地址

![DNS在OSI中的位置.png](./image/DNS在OSI中的位置.png)

简单来讲，DNS相当于一个翻译官，负责将域名翻译成ip地址

![DNS示意图](./image/DNS示意图.png)

- IP 地址：一长串能够唯一地标记网络上的计算机的数字
- 域名：是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识

DNS使用的是网络的查询，监听的是53号端口，通常DNS以UDP来查询，而当没有查询到完整的信息时，就会以TCP再次查询，所以启动DNS时，会同时启动TCP和UDP的53号端口。

### 域名和域名服务

#### 域名

域名是一个具有层次的结构，从上到下一次为根域名、顶级域名、二级域名、三级域名…

![域名](./image/域名.png)

例如 `www.xxx.com，www`为三级域名、`xxx`为二级域名、`com`为顶级域名，系统为用户做了兼容，域名末尾的根域名.一般不需要输入。

#### 域名的层级结构

DNS 中的域名都是⽤句点来分隔的，⽐如 `www.server.com`，这⾥的句点代表了不同层次之间的界限。在域名中，越靠右的位置表示其层级越⾼。

![域名的层级关系](./image/域名的层级关系.png)
![域名的层级结构](./image/域名的层级结构.png)

1. 根域名：整个域名系统的起点，理论上是所有域名的最高级别。`.root` 或者 `.`，通常是省略的。
2. 顶级域名（TLD, Top-Level Domain）：域名的最后部分，如 `.com`，`.cn` 等

   - 国家顶级域名（ccTLD, Country-code Top-Level Domain）：采用ISO3166的规定，这类域名用于代表具体的国家或地区，
     - 如 `.cn`(中国);`.uk`(英国);`.jp`(日本)等。
   - 通用顶级域名（gTLD, Generic Top-Level Domain）：这类域名不特指任何国家，而是面向全球使用。
     - 最常见的七个通用顶级域名，com--公司企业，org--非盈利组织，net--网络服务机构，int--国际组织，edu--美国专用教育机构，gov--美国的政府部门，mil--美国军事部门
   - 基础结构域名：这类域名用于互联网的基础架构，如.arpa，它主要用于反向DNS查找和某些特定的技术用途。
     - 基础结构顶级域只有一个arpa，是一个特殊的顶级域名（TLD），它是DNS（Domain Name System）基础设施的一部分，专门用于反向域名解析以及其他一些技术性的用途。被称为反向域名
3. 次级域名（SLD, Second-Level Domain）：位于顶级域名前的部分，如 `baidu.com` 里的 `baidu`，这个是用户可以进行注册购买的。
4. 主机域名：通常指的是在次级域名前的任何额外部分，可以包括多个层级的子域名，`baike.baidu.com` 里的 `baike`，这个是用户可分配的

例如：

```cpp
主机名.次级域名.顶级域名.根域名
mail.google.com.root
```

- `.root`是根域名，也可以写作 `.`，一般默认省略。
- `com`是顶级域名（gTLD）。
- `google`是次级域名。
- `mail`是子域名，也可以看作是主机域名的一部分。

Domain 分层架构呈现为树形结构，最顶上的为根服务器，然后为顶级域名（常见的如aliyun.com，sina.com.net，zte.com.cn）。目前，已经有超过 250 个顶级域名，每个顶级域名又可以进一步的划分出二级域名，二级域名又可以再划分出三级域名。依此类推，最终形成了我们现在见到的 `www.baidu.com.` 此类形式。（注：最后一个点表示根服务器，默认可忽略。）

Domain 的分层架构设计体现了高效简单可用，如下：

- 层级清晰：每一级域名代表一个层级，整个域名系统具有清晰的层次结构，简化每一层的管理和维护。
- 分布式管理：DNS 是一个分布式数据库，不同的域名由不同的 DNS 服务器管理。分布式管理的最大优点就是提高整个集群的健壮性，单点故障不会影响整个DNS系统。
- 易于扩展：可以根据需要简易的在树形结构上添加新的域名节点，而不会影响到整个系统的稳定性和性能。
- 易于解析：使得域名更容易被解析，有助于搜索和查找。也方便进行域名解析的缓存，提高了域名解析的效率。

##### `www.`域名

`www.` 不是一个独立的域名，而是一个域名前缀，通常被称为子域名，它常常用于指示一个网站的主服务器，即Web服务器。www 是 "World Wide Web" 的缩写，中文里常被称为“万维网”。

在标准的域名结构中，`www.` 前缀通常出现在顶级域名（TLD）和次级域名之前。例如，在 `www.example.com` 这个完整的域名中：

- `com` 是顶级域名，表明这个网站属于商业实体；
- `example` 是次级域名，由网站所有者选择，以唯一标识他们的网站；
- `www` 是子域名，通常用于指向网站的主要Web服务器。

然而，`www` 的使用并非强制性的。很多网站可以直接使用次级域名作为主要入口，例如 `example.com`，而不使用 `www` 前缀。在现代互联网实践中，使用 `www` 还是省略它，主要取决于网站所有者的偏好和配置。一些网站甚至会设置重定向，使得 `www.example.com` 和 `example.com` 都指向同一个网站，以避免搜索引擎索引问题和保持网站链接的一致性。

#### 域名服务器

在域名的每一层都会有一个域名服务器，如下图：

![域名服务器](./image/域名服务器.png)

##### 按照功能和部署位置分类

- 主DNS服务器：这是权威的DNS服务器，负责维护一个DNS区域的所有记录，并能直接响应DNS查询。
- 辅助DNS服务器：它们从主DNS服务器复制数据，作为备份，以防主服务器出现故障或负载过高时，可以继续提供服务。
- 缓存DNS服务器：这些服务器存储最近查询过的DNS记录，以加速后续的查询响应，减少对外部DNS服务器的请求。

##### 按照在DNS层次结构中的位置分类

- 根DNS服务器：位于DNS层次结构的顶端，提供顶级域名服务器的信息，负责指向顶级域名（TLD）服务器，是DNS查询的第一站。
- 顶级域名（TLD）服务器：负责管理其下一级的域名，如.com、.org等，并指向具体的权威DNS服务器。
- 权威DNS服务器：对于一个特定的域名，它是最终的权威信息来源，负责特定域名的解析，存储该域名的完整DNS记录，如A记录、MX记录等。
- 递归DNS服务器：接收终端用户的查询请求，负责递归地查找域名对应的IP地址，并将结果返回给查询者。

##### 两种域名服务器分类方法对比分析

- 主DNS服务器和权威DNS服务器在功能上有相似之处，权威服务器通常也是主服务器，但权威服务器的定义更加严格，它强调的是对特定域名的最终裁决权。
- 辅助DNS服务器的概念与DNS层次结构中的分类不直接对应，但它们可以存在于任何层级，作为权威服务器的备份。
- 缓存DNS服务器与递归DNS服务器在功能上有交集，递归服务器通常也会进行缓存，但递归服务器的重点在于它会全程追踪DNS查询直到得到最终答案。

简而言之，第一种分类方式侧重于服务器在网络中的角色和功能，而第二种分类方式则侧重于它们在DNS层次结构中的位置。两者从不同的维度描述了DNS系统的复杂性。在实际网络部署中，一台服务器可能同时承担多种角色，例如，一个DNS服务器可能既是权威服务器也是缓存服务器，同时还提供递归查询服务。

## DNS查询

### DNS查询类型

- 递归查询：DNS客户端向递归服务器发起查询，该服务器负责追踪所有必要的步骤来获得答案，并将结果返回给客户端。
- 迭代查询：DNS服务器之间传递查询，每次查询只返回指向下一个DNS服务器的信息，直到找到最终答案。

例如：
递归查询：如果 A 请求 B，那么 B 作为请求的接收者一定要给 A 想要的答案
![递归查询](./image/递归查询.png)

迭代查询：如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求
![迭代查询](./image/迭代查询.png)

### 域名解析(正向查询)

解析域名的过程如下：

- 首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表
- 若没有命中，则继续搜索操作系统的 DNS 缓存
- 若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果
- 若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询
  - 首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器
  - 本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址
  - 本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址
- 本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来
- 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起
- 至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起

流程如下图所示：
![DNS查询过程](./image/DNS查询过程.png)

下面解析步骤进行讲解，后面将采用命令行的形式来跟踪解析过程。当用户在地址栏键入并敲下回车键之后，域名解析就开始了。

**第一步：检查浏览器缓存中是否缓存过该域名对应的IP地址**:

用户通过浏览器浏览过某网站之后，浏览器就会自动缓存该网站域名对应的地址，当用户再次访问的时候，浏览器就会从缓存中查找该域名对应的IP地址，因为缓存不仅是有大小限制，而且还有时间限制（域名被缓存的时间通过属性来设置），所以存在域名对应的找不到的情况。当浏览器从缓存中找到了该网站域名对应的地址，那么整个解析过程结束，如果没有找到，将进行下一步骤。对于的缓存时间问题，不宜设置太长的缓存时间，时间太长，如果域名对应的发生变化，那么用户将在一段时间内无法正常访问到网站，如果太短，那么又造成频繁解析域名。

**第二步：如果在浏览器缓存中没有找到IP，那么将继续查找本机系统是否缓存过IP**:

如果第一个步骤没有完成对域名的解析过程，那么浏览器会去系统缓存中查找系统是否缓存过这个域名对应的地址，也可以理解为系统自己也具备域名解析的基本能力。在系统中，可以通过设置文件来将域名手动绑定到某上，文件位置在。对于普通用户，并不推荐自己手动绑定域名和，对于开发者来说，通过绑定域名和，可以轻松切换环境，可以从测试环境切换到开发环境，方便开发和测试。在系统中，黑客常常修改他的电脑的文件，将用户常常访问的域名绑定到他指定的上，从而实现了本地解析，导致这些域名被劫持。在或者系统中，文件在，修改该文件也可以实现同样的目的。

前两步都是在本机上完成的，所以没有在上面示例图上展示出来，从第三步开始，才正在地向远程DNS服务器发起解析域名的请求。

**第三步：向本地域名解析服务系统发起域名解析的请求**:

如果在本机上无法完成域名的解析，那么系统只能请求本地域名解析服务系统进行解析，本地域名系统一般都是本地区的域名服务器，比如你连接的校园网，那么域名解析系统就在你的校园机房里，如果你连接的是电信、移动或者联通的网络，那么本地域名解析服务器就在本地区，由各自的运营商来提供服务。对于本地服务器地址，系统使用命令就可以查看，在和系统下，直接使用命令来查看服务地址。一般都缓存了大部分的域名解析的结果，当然缓存时间也受域名失效时间控制，大部分的解析工作到这里就差不多已经结束了，负责了大部分的解析工作。

**第四步：向根域名解析服务器发起域名解析请求**:

本地域名解析器还没有完成解析的话，那么本地域名解析服务器将向根域名服务器发起解析请求。

**第五步：根域名服务器返回gTLD域名解析服务器地址**:

本地域名解析向根域名服务器发起解析请求，根域名服务器返回的是所查域的通用顶级域（）地址，常见的通用顶级域有、、、等。

**第六步：向gTLD服务器发起解析请求**:

本地域名解析服务器向gTLD服务器发起请求。

**第七步：gTLD服务器接收请求并返回Name Server服务器**:

服务器接收本地域名服务器发起的请求，并根据需要解析的域名，找到该域名对应的域名服务器，通常情况下，这个服务器就是你注册的域名服务器，那么你注册的域名的服务商的服务器将承担起域名解析的任务。

**第八步：Name Server服务器返回IP地址给本地服务器**:

服务器查找域名对应的地址，将地址连同值返回给本地域名服务器。

**第九步：本地域名服务器缓存解析结果**:

本地域名服务器缓存解析后的结果，缓存时间由时间来控制。

**第十步：返回解析结果给用户**:

解析结果将直接返回给用户，用户系统将缓存该地址，缓存时间由来控制，至此，解析过程结束。

这里对解析的步骤进行了一个简单的介绍分析，后面将通过命令行的形式来解析一个域名的具体解析过程。

### 正向解析(同上DNS查询)

1. 客户端查询：当用户在浏览器输入一个网址时，操作系统或浏览器内置的DNS解析器首先会查询本地缓存。如果缓存中有记录，将立即返回结果；否则，将查询请求发送给配置的递归DNS服务器。
2. 递归或迭代查询：
   1. 递归查询：如果没有缓存记录，解析器会向其配置的DNS服务器发送查询，该服务器会递归地查询直到找到结果或遇到错误。
   2. 迭代查询：DNS服务器可能只知道下一个查询服务器的地址，于是将这个信息返回给客户端的DNS解析器，由其继续查询。
3. 权威服务器响应：当递归DNS服务器或查询者最终联系到权威DNS服务器时，该服务器将返回请求的DNS记录，如IP地址、邮件服务器地址等。
4. 结果返回与缓存：递归DNS服务器将得到的响应返回给客户端，并将记录缓存起来，以备后续查询使用。缓存的时间长度由DNS记录中的TTL（Time to Live）值决定。

示例：
咱们以访问 `www.163.com` 这个域名为例，来看一看当你访问 `www.163.com` 时，会发生哪些事：

1. 先查找本地 DNS 缓存（自己的电脑上），有则返回，没有则进入下一步
2. 查看本地 hosts 文件有没有相应的映射记录，有则返回，没有则进入下一步
3. 向本地 DNS 服务器（一般都是你的网络接入服务器商提供，比如中国电信，中国移动）发送请求进行查询，本地DNS服务器收到请求后，会先查下自己的缓存记录，如果查到了直接返回就结束了，如果没有查到，本地DNS服务器就会向DNS的根域名服务器发起查询请求：请问老大， `www.163.com` 的ip是啥？
4. 根域名服务器收到请求后，看到这是个 .com 的域名，就回信说：这个域名是由 .com 老弟管理的，你去问他好了，这是.com老弟的联系方式（ip1）。
5. 本地 DNS 服务器接收到回信后，照着老大哥给的联系方式（ip1），马上给 .com 这个顶级域名服务器发起请求：请问 .com 大大，www.163.com 的ip 是啥？
6. `.com` 顶级域名服务器接收到请求后，看到这是 163.com 的域名，就回信说：这个域名是 .`163.com` 老弟管理的，你就去问他就行了，这是他的联系方式（ip2）
7. 本地 DNS 服务器接收到回信后，按照前辈的指引（ip2），又向 `.163.com` 这个权威域名服务器发起请求：请问 `163.com` 大大，请问 `www.163.com` 的ip是啥？
8. `163.com` 权威域名服务器接收到请求后，确认了是自己管理的域名，马上查了下自己的小本本，把 `www.163.com` 的ip告诉了 本地DNS服务器。
9. 本地DNS服务器接收到回信后，非常地开心，这下总算拿到了 `www.163.com`的ip了，马上把这个消息告诉了要求查询的客户（就是你的电脑）。由于这个过程比较漫长，本地DNS服务器为了节省时间，也为了尽量不去打扰各位老大哥，就把这个查询结果偷偷地记在了自己的小本本上，方便下次有人来查询时，可以快速回应。

总结起来就是三句话：

1. 从"根域名服务器"查到"顶级域名服务器"的NS记录和A记录（IP地址）
2. 从"顶级域名服务器"查到"次级域名服务器"的NS记录和A记录（IP地址）
3. 从"次级域名服务器"查出"主机名"的IP地址

![DNS解析过程02](./image/DNS解析过程02.png)
![DNS解析过程03](./image/DNS解析过程03.png)
![DNS解析过程](./image/DNS解析过程.png)

### 反向解析

DNS（Domain Name System）的反向解析是指将IP地址转换为域名的过程，与正向解析（将域名转换为IP地址）相对。反向解析主要应用于网络管理、安全审计以及邮件服务器认证等领域，特别是在验证邮件发送者的身份时尤为重要。

#### 反向解析的作用

- 网络安全：帮助识别网络上的设备，验证IP地址的合法性和归属，防止匿名攻击和垃圾邮件。
- 邮件服务器验证：邮件服务器通常会检查发送方的反向DNS记录，以确认发送者是否为已知实体，减少垃圾邮件和钓鱼邮件。
- 故障排除：在网络故障排查时，能够快速定位到具体的服务器或设备。
- 审计和监控：在日志记录和安全审计中，IP地址的反向解析有助于理解事件发生的上下文。

#### 反向解析的技术实现

反向解析是通过在DNS中添加特殊的记录——`PTR(Pointer)`记录来实现的。这些记录存储在特殊的子域中，对于IPv4地址，这个子域是 `in-addr.arpa`；对于IPv6地址，这个子域是 `ip6.arpa`。

##### IPv4反向解析示例

- 如果有一个IPv4地址 `192.0.2.1`，它的反向解析格式为 `1.2.0.192.in-addr.arpa`。
- 在DNS服务器中，需要为这个IP地址创建一个PTR记录，其值为相应的FQDN（Fully Qualified Domain Name）。

##### IPv6反向解析示例

对于IPv6地址，反向解析区域则以.ip6.arpa结尾。IPv6地址的反向解析格式遵循一种特殊的顺序，即地址的十六进制部分从右向左分组，每四个字符一组，然后逆序排列。例如，IPv6地址2001:db8::1的反向解析记录将位于 `1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa`区域中，但实际书写时会省略连续的0组，简化为 `1.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa`。

#### 配置反向解析

为了使反向解析工作，DNS服务器必须配置正确的PTR记录。这通常涉及到以下步骤：

1. 在DNS服务器上创建一个反向解析区域，对于IPv4是.in-addr.arpa区域，对于IPv6是.ip6.arpa区域。
2. 在相应的区域中创建PTR记录，将IP地址映射到域名。
3. 确保TTL（Time To Live）值设置适当，以便在IP地址或域名发生变化时，更新能够及时传播。

### 资源记录（RR）

DNS（Domain Name System）资源记录（Resource Record，简称RR）是DNS系统中核心的数据结构，用于存储各种与域名相关的数据，包括IP地址、邮件服务器信息、权威名称服务器和其他元数据。每个资源记录都包含了特定的信息，使得DNS能够执行其主要功能：域名到IP地址的转换以及其他多种用途。

#### 资源记录的结构

资源记录具有标准化的格式，由以下几部分组成：

1. 名称（Name）：标识该资源记录所属的域名。
2. 类型（Type）：定义了记录的种类，例如A记录、MX记录、CNAME记录等。
3. 类（Class）：通常为IN（Internet），表示该记录适用于互联网。
4. TTL（Time to Live）：定义了记录可以被缓存的时间长度。一旦超过TTL，记录将被视为过期，需要重新查询DNS服务器获取最新信息。
5. 数据（Data）：具体的数据，根据记录类型的不同而变化，如IP地址、邮件服务器信息或其他数据。

#### 常见的资源记录类型

以下是DNS中一些最常见的资源记录类型：

| 类型 | 编码 |                                                                          内容                                                                          |
| :---: | :--: | :----------------------------------------------------------------------------------------------------------------------------------------------------: |
|   A   |  1  |                                        将 DNS 域名映射到 IPv4 地址，基本作用是说明一个域名对应了哪些 IPv4 地址                                        |
|  NS  |  2  |                                             权威名称服务器记录，用于说明这个区域有哪些 DNS 服务器负责解析                                             |
| CNAME |  5  |                                                            别名记录，主机别名对应的规范名称                                                            |
|  SOA  |  6  | 起始授权机构记录，NS 记录说明了有多台服务器在进行解析，但哪一个才是主服务器，<br />NS 并没有说明，SOA 记录了说明在众多 NS 记录里哪一台才是主要的服务器 |
|  PTR  |  12  |                                            IP 地址反向解析，是 A 记录的逆向记录，作用是把 IP 地址解析为域名                                            |
|  MX  |  15  |                                                 邮件交换记录，指定负责接收和发送到域中的电子邮件的主机                                                 |
|  TXT  |  16  |                                                     文本资源记录，用来为某个主机名或域名设置的说明                                                     |
| AAAA |  28  |                                        将 DNS 域名映射到 IPv6 地址，基本作用是说明一个域名对应了哪些 IPv6 地址                                        |

1. A记录：地址记录，用于将域名映射到IPv4地址。
2. NS记录：名称服务器记录，用于指定负责某域名的权威DNS服务器。
3. CNAME记录：规范名记录，用于将一个域名映射到另一个域名。
4. SOA记录：起始授权记录，每个DNS区域都必须有一个SOA记录，它包含了关于该区域的重要管理信息，如主服务器、备份服务器、区域版本号等。
5. PTR记录：指针记录，用于反向解析，即将IP地址映射回域名。
6. MX记录：邮件交换记录，用于指定负责接收电子邮件的邮件服务器。
7. TXT记录：文本记录，可以包含任意文本信息，常用于SPF（Sender Policy Framework）记录，以帮助防止邮件欺骗。
8. AAAA记录：与A记录类似，但用于IPv6地址。
9. SRV记录：服务记录，用于指定特定的服务在何处可用，以及如何连接到该服务。
10. CAA记录：证书颁发机构记录，用于控制哪些CA可以为域名颁发SSL/TLS证书。

### 邮件交换器（MX，Mail eXchanger）记录

邮件交换器（MX，Mail eXchanger）记录是DNS（Domain Name System）中的一种重要记录类型，用于指示哪些邮件服务器被授权接收并处理发送给特定域名的电子邮件。MX记录不仅决定了邮件的接收地点，还定义了优先级，帮助邮件在遇到问题时选择备用路径。

#### MX记录的作用

1. 邮件服务器定位：当发送方尝试发送邮件至某一域名时，发送方的邮件服务器会查询该域名的MX记录，以确定邮件应发送至哪个邮件服务器。
2. 优先级分配：MX记录包含一个优先级数值，数值越低表示优先级越高。如果一个域名有多个MX记录，邮件将首先尝试发送到优先级最高的邮件服务器。如果首选邮件服务器不可达，邮件将被发送到次优先的服务器，以此类推。

#### MX记录的格式

MX记录由两部分组成：优先级和主机名。格式通常如下所示：

```s
<域名> IN MX <优先级> <邮件服务器主机名>
```

例如：

```s
example.com. IN MX 10 mail.example.com.
```

这表明 `mail.example.com`是 `example.com`域名的主要邮件服务器，且其优先级为10。

#### 如何设置MX记录

MX记录需要在域名的权威DNS服务器上进行设置。通常，这可以通过登录到DNS服务提供商的控制面板，找到DNS管理界面，然后添加或修改MX记录来完成。设置时，需要确保：

- 指定正确的邮件服务器主机名。
- 设置合适的优先级，确保主要和备用邮件服务器的正确排序。

#### MX记录的使用场景

- 多服务器冗余：企业可能拥有多个邮件服务器，以提供冗余和容错能力。MX记录允许定义多个邮件服务器，确保即使主要邮件服务器发生故障，邮件仍能被其他服务器接收。
- 外部邮件服务：如果使用第三方邮件服务提供商（如Google Workspace、Microsoft 365等），则需要在自己的域名DNS设置中添加提供商推荐的MX记录，以便所有邮件都路由至该服务。

#### MX记录的安全性和优化

- 安全性：MX记录的存在使得邮件发送者能够验证接收邮件的服务器，有助于防止垃圾邮件和恶意邮件。
- 性能优化：通过合理设置MX记录，可以确保邮件流量均匀分布，避免单一邮件服务器过载。

#### 资源记录的应用

资源记录的应用非常广泛，从基本的域名解析到复杂的网络服务配置，如：

- 域名解析：A记录和AAAA记录用于将域名转换为IP地址。
- 邮件服务：MX记录用于确定邮件应发送到哪个邮件服务器。
- 安全配置：TXT记录中的SPF和DKIM信息用于增强电子邮件的安全性。
- 服务发现：SRV记录用于定位特定服务的位置，例如LDAP或SIP服务。

## DNS缓存

在域名服务器解析的时候，DNS解析的结果会被缓存，使用缓存保存域名和IP地址的映射。

计算机中DNS的记录也分成了两种缓存方式：

- 浏览器缓存：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗
- 操作系统缓存：操作系统的缓存其实是用户自己配置的 hosts 文件

DNS缓存能够减少未来查询的延迟和网络负载。缓存的有效时间由TTL（Time To Live）决定，这是一个DNS记录在缓存中保留的时间。意思就是这个缓存可以存活多长时间，过了这个时间，本地 DNS 就会删除这条记录，删除了缓存后，你再访问，就要重新走一遍上面的流程，获取最新的地址。

- DNS缓存提高效率
  - DNS查询涉及多个步骤，从客户端到递归DNS服务器，再到权威DNS服务器，最后返回结果。每次查询都需要在网络中往返，这可能会消耗大量时间和带宽。DNS缓存通过存储之前查询的结果，可以显著减少重复查询的次数，因为如果结果已经被缓存，那么后续的相同查询可以直接从缓存中获取答案，而无需再次发送请求到远程服务器。这样就减少了网络延迟，节省了带宽，提高了整体的查询效率。
- 缓存导致准确率损失
  - 然而，DNS缓存也会带来一个问题，那就是缓存中的信息可能不是最新的。例如，当一个网站的IP地址发生改变，或者域名记录进行了更新，这些更改需要一定时间才能在全球的DNS缓存中生效。这是因为DNS记录在缓存中有一个TTL（Time to Live）值，这个值定义了记录可以在缓存中保存多久。在TTL到期之前，即使记录已经发生了变化，DNS服务器仍然会返回旧的缓存记录，这就可能导致查询结果的不准确。
  - 例如，假设一个网站的IP地址从192.0.2.1改为192.0.2.2，新的DNS记录可能已经在全球的权威DNS服务器上更新，但是那些TTL未到期的DNS缓存中仍然会返回192.0.2.1这个旧地址，导致部分用户的访问失败或被导向错误的位置。

## DNS协议

- 报文头：包含标识、标志、问题数量、答案数量、权威数量和额外数量等字段。
- 查询报文：客户端发送的请求，包含请求的域名和请求类型。
- 响应报文：DNS服务器的回应，包含请求的资源记录或其他服务器的信息。

### DNS协议段

![DNS协议在以太帧上的位置](./image/DNS协议在以太帧上的位置.png)

DNS协议的层级在传输层之上，常见的是用UDP作为传输层，用的是知名端口53，当然也有TCP的DNS。

![DNS协议字段](./image/DNS协议字段.png)

1. 标识(identifier)

   - 标识占16 位，标识用于DNS的请求和响应是不是一对。对于一对的请求和响应，标识字段是一样的。
2. 标志(flags)

   - 标志占 16 位，其包含8个标志字段，其含义分别如下
   - QR 查询应答标志，0表示这是查询报文，1表示这是应答报文。
   - opcode 查询应答类型，0表示标准查询，1表示反向查询，2表示请求服务器状态。
   - AA 表示权威回答( authoritative answer )，意味着当前查询结果是由域名的权威服务器给出的，仅由应答报文使用。
   - TC 位表示截断( truncated )，使用 UDP 时，如果应答超过 512 字节，只返回前 512 个字节，仅当DNS报文使用UDP服务时使用。DNS 协议使用UDP服务，但也明确了 『当 DNS 查询被截断时，应该使用 TCP 协议进行重试』 这一规范。
   - RD 表示递归查询标志 ( recursion desired )，在请求中设置，并在应答中返回。
     - 该位为 1 时，服务器必须处理这个请求：如果服务器没有授权回答，它必须替客户端请求其他 DNS 服务器，这也是所谓的 递归查询；
     - 该位为 0 时，如果服务器没有授权回答，它就返回一个能够处理该查询的服务器列表给客户端，由客户端自己进行 迭代查询。
   - RA 位表示可递归 ( recursion available )，如果服务器支持递归查询，就会在应答中设置该位，以告知客户端。仅由应答报文使用。
   - zero 这三位未使用，固定为0。
   - rcode 表示返回码（reply code），用来返回应答状态，常用返回码：0表示无错误，2表示格式错误，3表示域名不存在。
3. 问题数（question count ）

   - 占16位，表示后面问题节中的记录个数
4. 应答资源记录数（answer count）

   - 占16 位，表示答案节中的记录个数
5. 授权资源记录数（authority record count）

   - 占16 位，表示授权信息节中的记录个数
6. 额外资源记录数（additional record count）

   - 占16 位，表示额外信息节中的记录个数
7. 查询问题

   - 询问题部分由多个（question count）问题构成，每个问题的格式都相同，分为3个段：
     1. 查询名，以example.com为例，将被编码为7example3com0这13个字节。数字7表示后面example的长度，最后0则表示后面没跟任何字符，相当于一个结束符。单个字节最长可表示255大小，因此每一级域名的最大长度也是255。
     2. 查询类型（type）
     3. 查询类（class），通常为 1 ，表示 TCP/IP 互联网地址；

### 查询报文(Query Message)

DNS查询报文由客户端发送至DNS服务器，请求关于特定域名的信息。报文结构如下：

1. 事务ID (Transaction ID)：16位长度，用于匹配请求和响应报文。
2. 标志 (Flags)：16位，包含以下字段：
   - QR (Query/Response)：1位，0表示查询，1表示响应。
   - Opcode：4位，指定请求的操作类型，如标准查询（0）、反向查询（1）等。
   - AA (Authoritative Answer)：1位，仅在响应中有效，表示应答服务器是否是权威服务器。
   - TC (Truncation)：1位，表示报文是否被截断。
   - RD (Recursion Desired)：1位，表示客户端是否希望DNS服务器递归查询。
   - RA (Recursion Available)：1位，仅在响应中有效，表示DNS服务器是否支持递归查询。
   - Z：3位，保留未使用。
   - RCODE (Response Code)：4位，响应代码，仅在响应报文中有效，表示响应状态。
3. 问题计数 (Question Count)：16位，表示问题数量，通常为1。
4. 回答资源记录数 (Answer RRs Count)：16位，表示响应报文中回答资源记录的数量，查询报文中为0。
5. 权威资源记录数 (Authority RRs Count)：16位，表示响应报文中权威资源记录的数量，查询报文中为0。
6. 额外资源记录数 (Additional RRs Count)：16位，表示响应报文中额外资源记录的数量，查询报文中为0。
7. 问题部分 (Question Section)：包含了要查询的域名和查询类型（如A记录、MX记录等）。

### 响应报文

DNS响应报文由DNS服务器发送回客户端，响应客户端的查询请求。响应报文结构与查询报文类似，但是某些字段的值会根据实际情况有所不同：

1. 事务ID (Transaction ID)：与查询报文相同。
2. 标志 (Flags)：QR位为1，表示这是一个响应报文。其他的标志位根据响应的具体情况设定。
3. 问题计数 (Question Count)：通常与查询报文中相同。
4. 回答资源记录数 (Answer RRs Count)：表示响应中提供的回答资源记录的数量。
5. 权威资源记录数 (Authority RRs Count)：表示响应中提供的权威资源记录的数量，如NS记录，指示权威服务器。
6. 额外资源记录数 (Additional RRs Count)：表示响应中提供的额外资源记录的数量，如A记录，用于快速访问权威或额外的DNS信息。
7. 问题部分 (Question Section)：与查询报文的问题部分相同。
8. 回答部分 (Answer Section)：包含响应的资源记录，如IP地址。
9. 权威部分 (Authority Section)：包含权威资源记录，用于指示权威DNS服务器。
10. 额外部分 (Additional Section)：包含额外的资源记录，如相关A记录，帮助客户端更快地解析其他相关的域名。

DNS查询和响应报文通过UDP或TCP协议在网络上传输，UDP通常用于较小的报文，而较大的报文或需要可靠传输的情况会使用TCP。

## DNS扩展问题

### DNS的安全性

- DNSSEC(DNS Security Extensions)：DNS安全扩展，使用数字签名验证DNS记录的真实性，防止DNS欺骗和中间人攻击。
- DNS缓存污染：一种攻击手段，黑客试图修改DNS缓存中的记录，以重定向流量到恶意站点。

### DNS的优化和扩展

- DNS AnyCast：使用Anycast IP地址，使得最近的DNS服务器可以响应查询，减少延迟。
- DNS over HTTPS (DoH) 和 DNS over TLS (DoT)：通过加密通道传输DNS查询，增加隐私和安全性。
- DNS Cache：存储最近的查询结果，减少对远程DNS服务器的查询，加快响应速度。

### DNS的维护和管理

- DNS服务器的配置需要精确且经常更新，以反映域名和IP地址的变化。
- 管理员负责确保DNS记录的正确性和安全性，监控DNS服务器的健康状态和性能。

## 经典面试问题

### 对于DNS服务器若采⽤集中式的设计有以下问题

1. 单点故障
   如果 DNS 服务器崩溃，那么整个⽹络随之瘫痪。通信容量(traaffic volume) ，单个 DNS 服务器不得不处理所有的
   DNS 查询，这种查询级别可能是上百万上千万级，⼀台服务器很难满⾜;
2. 远距离集中式数据库
   单个 DNS 服务器不可能 邻近 所有的⽤户，假设在美国的 DNS 服务器不可能临近让澳⼤利亚的查询使⽤，其中查
   询请求势必会经过低速和拥堵的链路，造成严重的时延;
3. 维护
   维护成本巨⼤，⽽且还需要频繁更新。

### 根域名服务器为什么只有13个?

主要的原因：
与一个不分片的UDP报文的大小有关系。

> 最初的DNS域名查询默认使用UDP协议，而使用UDP传输的DNS查询响应（Query Response）报文，不希望任何形式的分片,包括DNS应用层的分片V、以及IP层的分片。。换句话说，要求使用唯一的UDP报文传输DNS响应。
> 绝大多数的网络接口类型支持IP报文≥576 字节无需分片自由通行，考虑到以上诸因素，IETF决定将DNS报文体限制在512字节。每一个根域名服务器占用32字节，其中包括根域名的名称、IP地址、TTL(Time To Live)等参数。
> 所以：早期的DNS 查询结果是一个512字节的UDP 数据包。

一个512字节的UDP 数据包，**一个根域名服务器占用32个字节(因为，IP地址由32位二进制数组成)， 13根域名服务器一共占用416字节。**

剩余的96字节用于包装DNS报文头以及其它协议参数。

所以，从空间上来说，一个512字节的dns数据包，最多可以容纳13个服务器的地址，没有多余的空间容纳第14个根域名服务器的32字节。

因此就规定全世界有13个根域名服务器，编号从a.root-servers.net一直到m.root-servers.net。

这13台根域名服务器由12个组织独立运营。其中，Verisign 公司管理两台根域名服务器：A 和 J。每家公司为了保证根域名服务器的可用性，会部署多个节点，比如单单Verisign 一家公司就部署了104台根域名服务器（2016年1月数据）。所以，根域名服务器其实不止13台。

**这13个根域名服务器并不等于13台物理服务器**!

容易被大众误解的是，这13个根域名服务器并不等于13台物理服务器，而是代表着13个全球IP地址，由12个机构来管理，其中美国最大电信运营商Verizon管理两个根域名全球IP地址。

截至到今天为止，全球一共有**996台服务器实例（Instances）**，遍布5大洲4大洋。

![13个根域名服务器位置](./image/13个根域名服务器位置.png)

既然根域名服务器只有13个全球IP，而物理服务器却有996台，到底怎么分配的？

答案是： 使用**BGP泛播技术（Anycast）**

以Verizon管理的“198.41.0.4”为例，在全球一共分布在28个站点，每个站点的服务器，都使用同一个IP—— “198.41.0.4”， 反过来说， “198.41.0.4” 是一个全球IP， 在全球被 28 服务器使用。

> 问题是：IP地址在互联网上重复使用，会不会有什么问题？

咱们学习网络知识的时候，特别在局域网配置的时候，着重强调IP地址要唯一，不允许有重复使用IP地址的情况发生。但是，在互联网上不同站点可以使用相同的IP地址，只要使用方是IP地址的合法使用者。

> “198.41.0.4”就会在28个站点，通过BGP路由协议，28次扩散到Internet路由表。

#### 全球IP的路由策略

全球的主机究竟挑选哪个“198.41.0.4”来使用呢？当然是距离自己最近的，用BGP的专业术语表达就是最优路径。

#### 泛播技术有哪些优点？

根域名服务器特别重要，曾经有黑客集中攻击它，差一点就成功了，因为13个服务器中某些依然没有被打趴下，源于服务器的全球式分布。

一朝被蛇咬，十年怕草绳。 互联网管理机构发现对付DDoS 攻击最有效的方法，就是分布式部署根域名服务器。于是，使用了泛播技术，全球有了996台实例。

如果有一天996台不够用，可以添加任意多台服务器，因为全球IP可以重复使用。

### DNS劫持

先回顾一下DNS劫持的概念？

DNS劫持即通过某种技术手段，篡改正确域名和IP地址的映射关系，使得域名映射到了错误的IP地址，因此可以认为DNS劫持是一种DNS重定向攻击。DNS劫持通常可被用作域名欺诈，如在用户访问网页时显示额外的信息来赚取收入等；也可被用作网络钓鱼，如显示用户访问的虚假网站版本并非法窃取用户的个人信息。

#### DNS劫持 是如何产生的呢？

下面大概说几种DNS劫持方法：

1. 本机DNS劫持

   攻击者通过某些手段使用户的计算机感染上木马病毒，或者恶意软件之后，恶意修改本地DNS配置，比如修改本地hosts文件，缓存等
2. 路由DNS劫持

   很多用户默认路由器的默认密码，攻击者可以侵入到路由管理员账号中，修改路由器的默认配置
3. 攻击DNS服务器

   直接攻击DNS服务器，例如对DNS服务器进行DDOS攻击，可以是DNS服务器宕机，出现异常请求，还可以利用某些手段感染dns服务器的缓存，使给用户返回来的是恶意的ip地址

#### DNS劫持大事记

##### 事件1：《AWS route53 BGP路由泄漏事件》

- 事件危害：据不完全统计，DNS劫持导致两个小时内有多个用户的以太坊钱包被转账清空，共计至少13000美元的资产被黑客盗取。
- 事件还原： 事件发生在2018年4月24日。黑客针对四段分配给AWS，本应作为AWS route53 DNS服务器服务地址的IP空间(205.251.192.0/23, 205.251.194.0/23, 205.251.196.0/23, 205.251.198.0/23)发布了虚假的BGP路由，导致在BGP泄漏的两个小时期间，本应该AWS route53 DNS服务器的DNS查询都被重定向到了黑客的恶意DNS服务器。且黑客DNS劫持的目标十分明确，恶意DNS服务器只响应对myetherwallet.com的查询，其他域名的查询均返回SERVFAIL。一旦用户没有注意“网站不安全”的提示而访问myetherwallet.com登录自己的以太坊钱包，黑客就可以轻易获取用户的私钥进而窃取用户的数字货币资产。正常情况的DNS，和劫持后的DNS的情况，请参考如下攻击示意图（来自[cloudflare博客](https://yq.aliyun.com/go/articleRenderRedirect?url=https%3A%2F%2Fblog.cloudflare.com%2Fbgp-leaks-and-crypto-currencies%2F)）：

正常情况：
![正常情况的DNS](./image/正常情况的DNS.png)

BGP泄漏后：
![BGP泄漏后](./image/BGP泄漏后.png)

##### 事件2：《巴西银行钓鱼事件》

- 事件危害：黑客诱导原本想访问正常银行网站的受害者访问到钓鱼网站，并恶意窃取受害者的银行账目密码信息。
- 事件还原：事件发生在2018年。黑客利用D-Link路由器的漏洞，入侵了至少500个家用路由器。黑客入侵后更改受害者路由器上的DNS配置，将受害者的DNS请求重定向到黑客自己搭建的恶意DNS服务器上。黑客入侵后更改受害者路由器上的DNS配置，将受害者的DNS请求重定向到黑客自己搭建的恶意DNS服务器上，最终诱导原本想访问正常银行网站的受害者访问到钓鱼网站，并恶意窃取受害者的银行账目密码信息。

![巴西银行钓鱼事件](./image/巴西银行钓鱼事件.png)

上面两个案例都是触目惊心啊。接下来我们来介绍一下黑客们是怎么做到DNS劫持的？

#### DNS劫持分类

我们按照客户端侧--递归DNS服务器--权威DNS服务器的路径，将DNS劫持做如下分类：

##### 本地DNS劫持

客户端侧发生的DNS劫持统称为本地DNS劫持。本地DNS劫持可能是：

1. 黑客通过木马病毒或者恶意程序入侵PC，篡改DNS配置(hosts文件，DNS服务器地址，DNS缓存等)。
2. 黑客利用路由器漏洞或者破击路由器管理账号入侵路由器并且篡改DNS配置。
3. 一些企业代理设备（如Cisco Umbrella intelligent proxy）针对企业内部场景对一些特定的域名做DNS劫持解析为指定的结果。

##### DNS解析路径劫持

DNS解析过程中发生在客户端和DNS服务器网络通信时的DNS劫持统一归类为DNS解析路径劫持。通过对DNS解析报文在查询阶段的劫持路径进行划分，又可以将DNS解析路径劫持划分为如下三类：

###### DNS请求转发

通过技术手段(中间盒子，软件等)将DNS流量重定向到其他DNS服务器。
案例：
![巫俊峰, 沈瀚. 基于旁路抢答机制的异网DNS管控实践. 电信技术[J]](./image/巫俊峰,%20沈瀚.%20基于旁路抢答机制的异网DNS管控实践.%20电信技术[J].png)

###### DNS请求复制

利用分光等设备将DNS查询复制到网络设备，并先于正常应答返回DNS劫持的结果。
案例：一个DNS查询抓包返回两个不同的应答。

![一个DNS查询抓包返回两个不同的应答](./image/一个DNS查询抓包返回两个不同的应答.png)

###### DNS请求代答

网络设备或者软件直接代替DNS服务器对DNS查询进行应答。
案例：一些DNS服务器实现了SERVFAIL重写和NXDOMAIN重写的功能。

![DNS请求代答](./image/DNS请求代答.png)

##### 篡改DNS权威记录

篡改DNS权威记录 我们这里指的黑客非法入侵DNS权威记录管理账号，直接修改DNS记录的行为。
案例：
黑客黑入域名的管理账户，篡改DNS权威记录指向自己的恶意服务器以实现DNS劫持。
![篡改DNS权威记录](./image/篡改DNS权威记录01.png)

黑客黑入域名的上级注册局管理账户，篡改域名的NS授权记录，将域名授权给黑客自己搭建的恶意DNS服务器以实现DNS劫持。
![篡改DNS权威记录](./image/篡改DNS权威记录02.png)

黑客黑入域名的上级注册局管理账户，篡改域名的NS授权记录，将域名授权给黑客自己搭建的恶意DNS服务器以实现DNS劫持。（以上参考[fireeye博客](https://yq.aliyun.com/go/articleRenderRedirect?url=https%3A%2F%2Fwww.fireeye.com%2Fblog%2Fthreat-research%2F2019%2F01%2Fglobal-dns-hijacking-campaign-dns-record-manipulation-at-scale.html)）

##### DNS劫持应对策略

DNS劫持在互联网中似乎已经变成了家常便饭，那么该如何应对各种层出不穷的DNS劫持呢？如果怀疑自己遇到了DNS劫持，首先要做的事情就是要确认问题。

##### 如何确认DNS劫持

查看路由器DNS配置是否被篡改。
可以使用一些全网拨测的工具确认DNS劫持和其影响范围。在此隆重介绍一下，阿里的DNS域名检测工具于国庆后已经正式上线，地址是：[阿里云网站运维检测平台](https://zijian.aliyun.com/#/domainDetect)

![阿里云网站运维检测平台](./image/阿里云网站运维检测平台.png)

通过工具查看回复DNS应答的DNS服务器，确认DNS解析是否被重定向。
• [whatismydnsresolver](http://whatismydnsresolver.com/)
移动端可以安装一些DNS相关的测试工具进行排查：
• 安卓 ping & dns
• IOS IOS iNetTools

##### DNS劫持防范

• 安装杀毒软件，防御木马病毒和恶意软件；定期修改路由器管理账号密码和更新固件。
• 选择安全技术实力过硬的域名注册商，并且给自己的域名权威数据上锁，防止域名权威数据被篡改。
• 选择支持DNSSEC的域名解析服务商，并且给自己的域名实施DNSSEC。DNSSEC能够保证递归DNS服务器和权威DNS服务器之间的通信不被篡改。阿里云DNS作为一家专业的DNS解析服务厂商，一直在不断完善打磨产品功能，DNSSEC功能已经在开发中，不日就会上线发布。
• 在客户端和递归DNS服务器通信的最后一英里使用DNS加密技术，如DNS-over-TLS，DNS-over-HTTPS等。
在此《DNS攻击防范科普系列》已经完结，欢迎大家给我们留意反馈自己对DNS攻击防范对看法。

##### DNS 劫持 与 HTTP 劫持

通过上面的讲解，我们都知道了，DNS 完成了一次域名到 IP 的映射查询，当你在访问 `www.baidu.com` 时，能正确返回给你 百度首页的 ip。

但如果此时 DNS 解析出现了一些问题，当你想要访问 `www.baidu.com` 时，却返回给你 `www.google.com` 的 `ip`，这就是我们常说的 `DNS` 劫持。

与之容易混淆的有 `HTTP` 劫持。

那什么是 `HTTP` 劫持呢？

你一定见过当你在访问 某个网站时，右下角也突然弹出了一个扎眼的广告弹窗。这就是 `HTTP` 劫持。

借助别人文章里的例子，它们俩的区别就好比是

DNS劫持是你想去机场的时候，把你给丢到火车站。
HTTP劫持是你去机场途中，有人给你塞小广告。

### HttpDNS

传统DNS存在哪些问题？

1）域名缓存问题：导游记忆记错了
2）域名转发问题：A运营商偷懒转给B运营商
3）出口NAT问题：NAT转换后DNS误判运营商
4）域名更新问题：DNS的域名TTL有效期跟不上场景切换
5）解析延迟问题：递归查询时间长

#### 例子： 用户侧DNS被劫持，hosts被篡改

如下是我们的域名在用户机器上被篡改的实例，通过修改hosts文件，可以看到下面的域名被篡改成了 `127.0.0.1`。

![用户侧DNS被劫持，hosts被篡改](./image/用户侧DNS被劫持，hosts被篡改.png)

#### 例子2. 缓存DNS服务器污染，返回客户端错误IP

2014年1月21日下午3点，国内顶级域的根服务器出现异常，许多知名网站的域名均被劫持到一个错误的IP地址上，至少有2/3的国内网站受到影响，用户无法正常访问。

根服务器恢复后，由于DNS缓存问题，部分地区用户“断网”现象仍持续了几个小时。

#### 例子3. DNS缓存时间较长，短则10分钟，长则几小时

DNS的解析机制为了提升效率，在很多地方会有缓存，例如本机的缓存，DNS服务器上的缓存。缓存带来了效率上的提升，但同时却给故障处理带来了不小的麻烦，即：当我们将故障的机器下线或者将DNS指向的主机地址修改以后，用户并不能立刻感知新的主机地址，在缓存有效期内还是会继续访问旧的主机。

#### HTTPDNS工作模式

定义：不走传统的DNS解析，而是自己搭建基于HTTP协议的DNS服务器集群，分布在多个地点和多个运营商，当客户端需要DNS解析的时候，直接通过HTTP协议进行请求这个服务器集群，获得就近的地址。

1. 在客户端的SDK里动态请求服务端，获取HTTPDNS服务器的ip列表，缓存到本地。SDK也会在本地缓存DNS域名解析的结果。这个缓存和本地DNS的缓存不一样，不是整个运营商统一做的，而是手机应用来做的，如何更新，何时更新。
2. 如果本地无，就需要请求HTTPDNS的服务器，在本地的ip列表中，选择一个发出HTTP请求，返回一个要访问的网站的ip列表。手机客户端知道手机坐在的运营商，可以精确做到全局负载均衡。

#### HTTPDNS的缓存设计

解析的过程不需要本地DNS服务递归调用一大圈，一个HTTP请求直接搞定，本地也有缓存，过期时间，更新时间都可以自己控制。
缓存设计模式三层：客户端，缓存，数据源

- 对于应用架构，就是应用，缓存，数据库。tomcat，redis，mysql
- 对于HTTPDNS来说，就是手机客户端，dns缓存，httpdns服务器
  例如dns缓存在内存中，也可以持久化到存储上，app重启后，就可以尽快的从存储中加载上次积累的解析结果。
  sdk中的缓存会严格按照缓存过期时间，如果没有命中，或已经过期，则不允许使用过期记录，会发起一次解析，保障记录是新的。
  解析可以是同步或异步的。
  同步更新的优点是实时性好，缺点是如果有多个请求都发现过期的时候，会同时请求HTTPDNS，浪费资源。对应到应用架构中缓存的Cache-Aside机制，先读缓存，不命中读数据库，同时写入到缓存。
  异步的优点是多个请求都过期的情况可以合并为一个，同时可以在即将过期的时候，创建一个任务进行预加载，防止过期之后再刷新成为预加载。缺点是当请求拿到过期数据，如果可以请求就没问题，如果不能请求，则失败，等下次缓存更新后，再请求方能成功。
  对应于应用架构中缓存的Refresh-Ahead机制，即业务仅仅访问缓存，当过期就定期刷新。

#### HTTPDNS调度设计

客户端嵌入了SDK，在客户端HTTPDNS服务端可以根据手机的国家，省市地点，运营商，选择最佳的服务节点。

小结：

- 传统的DNS有解析慢，更新不及时，转发跨运营商，nat跨运营商等问题，影响了流量的调度。
- HTTPDNS通过客户端sdk和服务端，直接解析dns，绕过了传统dns缺点，实现智能调度。

#### 功能说明

HTTPDNS使用HTTP协议进行域名解析，代替现有基于UDP的DNS协议，域名解析请求直接发送到阿里云的HTTPDNS服务器，从而绕过运营商的Local DNS，能够避免Local DNS造成的域名劫持问题和调度不精准问题。

| 功能           | 说明                                                                       |
| -------------- | -------------------------------------------------------------------------- |
| 防劫持         | 绕过运营商Local DNS，避免域名劫持，让每一次访问都畅通无阻。                |
| 精准调度       | 基于访问的来源IP，获得最精准的解析结果，让客户端就近接入业务节点。         |
| 0ms解析延迟    | 通过热点域名预解析、缓存DNS解析结果、解析结果懒更新策略等方式实现0解析延迟 |
| 快速生效       | 避免Local DNS不遵循权威TTL，解析结果长时间无法更新的问题                   |
| 降低解析失败率 | 有效降低无线场景下解析失败的比率                                           |

- 防劫持
  HTTPDNS代替了传统的LocalDNS完成递归解析的功能，基于HTTP协议的设计可以适用于几乎所有的网络环境，同时保留了鉴权、HTTPS等更高安全性的扩展能力，避免恶意攻击劫持行为。
- 精准调度
  传统域名解析的调度精准性问题，本质根源在于Local DNS的部署和分配机制上。由于碎片化的管理方式，这些环节的服务质量同样很难得到保障。HTTPDNS在递归解析实现上优化了与权威DNS的交互，通过edns-client-subnet协议将终端用户的IP信息直接交付给权威DNS，这样权威DNS就可以忽略Local DNS IP信息，根据终端用户的IP信息进行精准调度，避免Local DNS的坐标干扰
- DNS解析0延迟：

  - 构建客户端DNS缓存；
    - 通过合理的DNS缓存，我们确保每次网络交互的DNS解析都是从内存中获取IP信息，从而大幅降低DNS解析开销。根据业务的不同，我们可以制订更丰富的缓存策略，如根据运营商缓存，可以在网络切换的场景下复用已缓存的不同运营商线路的域名IP信息，避免网络切换后进行链路重选择引入的DNS网络解析开销。另外，我们还可以引入IP本地化离线存储，在客户端重启时快速从本地读取域名IP信息，大幅提升首页载入效率。
  - 热点域名预解析；
    - 在客户端启动过程中，我们可以通过热点域名的预解析完成热点域名的缓存载入。当真正的业务请求发生时，直接由内存中读取目标域名的IP信息，避免传统DNS的网络开销。
  - 懒更新策略；
    - 绝大多数场景下业务域名的IP信息变更并不频繁，特别是在单次APP的使用周期内，域名解析获取的IP往往是相同的（特殊业务场景除外）。因此我们可以利用DNS懒更新策略来实现TTL过期后的DNS快速解析。所谓DNS懒更新策略即客户端不主动探测域名对应IP的TTL时间，当业务请求需要访问某个业务域名时，查询内存缓存并返回该业务域名对应的IP解析结果。如果IP解析结果的TTL已过期，则在后台进行异步DNS网络解析与缓存结果更新。通过上述策略，用户的所有DNS解析都在与内存交互，避免了网络交互引入的延迟。

#### 实现方案

**服务端**:
服务端提供API接口,app端直接通过ip地址访问,ip地址可以有多个

请求方式：HTTP GET

URL参数说明：

| 名称 | 是否必须 | 描述                                                     |
| ---- | -------- | :------------------------------------------------------- |
| host | 必须     | 要解析的域名                                             |
| ip   | 可选     | 用户的来源IP，如果没指定这个参数，默认使用请求连接的源IP |

请求示例：

- 示例1（默认来源IP）：[http://x.x.x.x/d?host=www.suning.com](http://x.x.x.x/d?host=www.suning.com)
- 示例2（指定来源IP）：[http://x.x.x.x/d?host=www.suning.com&amp;ip=185.53.179.6](http://x.x.x.x/d?host=www.suning.com&ip=185.53.179.6)

考虑到服务IP防攻击之类的安全风险，为保障服务可用性，HTTPDNS同时提供多个服务IP，当某个服务IP在异常情况下不可用时，可以使用其它服务IP进行重试。

请求成功时，HTTP响应的状态码为200，响应结果用JSON格式表示，示例如下：

```json
{
  "host": "www.suning.com",
  "ips": [
    "112.84.104.48"
  ],
  "ttl": 57,
  "origin_ttl": 120
}
```

请求失败的响应示例：

```json
{
  "code": "MissingArgument"
}
```

错误码列表如下：

| 错误码           | HTTP状态码 | 描述             |
| ---------------- | ---------- | ---------------- |
| MissingArgument  | 400        | 缺少必要参数     |
| InvalidHost      | 400        | 域名格式不合法   |
| MethodNotAllowed | 405        | 不支持的HTTP方法 |
| InternalError    | 500        | 服务端内部错误   |

错误处理：
异常下的出错兼容逻辑,主要包括异步请求,重试,降级

- 异步请求
  - 访问HTTPDNS服务时，应该使用异步请求的策略，避免解析延迟太大而对业务造成影响，特别是在网络环境异常或HTTPDNS服务IP异常不可用时，如果用同步访问，需要等待网络超时后才会返回解析失败，这个超时时间较大，可能对业务的使用体验造成很大影响。
  - 异步请求策略：解析域名时，如果当前缓存中有TTL未过期的IP，可直接使用；如果没有，则立刻让此次请求降级走原生LocalDNS解析，同
  时另起线程异步地发起HTTPDNS请求进行解析，更新缓存，这样后续解析域名时就能命中缓存。

- 重试
  - 访问HTTPDNS服务解析域名时，如果请求HTTPDNS服务端失败，即HTTP请求没有返回，可以进行重试。
  - 大部分情况下，这种访问失败是由于网络原因引起的，重试可以解决。

- 降级
  - 不管是因为什么原因，当通过HTTPDNS服务无法获得域名对应的IP时，都必须降级：使用标准的DNS解析，通过Local DNS去解析域名。

**Android端**:
OkHttp默认使用系统DNS服务InetAddress进行域名解析，但同时也暴露了自定义DNS服务的接口，通过该接口我们可以优雅地使用HttpDns。

- 自定义DNS接口

OkHttp暴露了一个Dns接口，通过实现该接口，我们可以自定义Dns服务：

```java
public class OkHttpDns implements Dns {
    private static final Dns SYSTEM = Dns.SYSTEM;
    HttpDnsService httpdns;//httpdns 解析服务
    private static OkHttpDns instance = null;
    private OkHttpDns(Context context) {
        this.httpdns = HttpDns.getService(context, "account id");
    }
    public static OkHttpDns getInstance(Context context) {
        if(instance == null) {
            instance = new OkHttpDns(context);
        }
        return instance;
    }
    @Override
    public List<InetAddress> lookup(String hostname) throws UnknownHostException {
        //通过异步解析接口获取ip
        String ip = httpdns.getIpByHostAsync(hostname);
        if(ip != null) {
            //如果ip不为null，直接使用该ip进行网络请求
            List<InetAddress> inetAddresses = Arrays.asList(InetAddress.getAllByName(ip));
            Log.e("OkHttpDns", "inetAddresses:" + inetAddresses);
            return inetAddresses;
        }
        //如果返回null，走系统DNS服务解析域名
        return Dns.SYSTEM.lookup(hostname);
    }
}
```

- 创建OkHttpClient

创建OkHttpClient对象，传入OkHttpDns对象代替默认Dns服务：

```java
private void okhttpDnsRequest() {
    OkHttpClient client = new OkHttpClient.Builder()
    .dns(OkHttpDns.getInstance(getApplicationContext()))
    .build();
    Request request = new Request.Builder()
    .url("http://www.aliyun.com")
    .build();
    Response response = null;
    client.newCall(request).enqueue(new Callback() {
        @Override
        public void onFailure(Call call, IOException e) {
            e.printStackTrace();
        }
        @Override
        public void onResponse(Call call, Response response) throws IOException {
            if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
                DataInputStream dis = new DataInputStream(response.body().byteStream());
                int len;
                byte[] buff = new byte[4096];
                StringBuilder result = new StringBuilder();
                while ((len = dis.read(buff)) != -1) {
                    result.append(new String(buff, 0, len));
                }
                Log.d("OkHttpDns", "Response: " + result.toString());
            }
        });
}
```

- 总结

相比于通用方案，OkHttp+HttpDns有以下两个主要优势：

```cpp
实现简单，只需通过实现Dns接口即可接入HttpDns服务
 
通用性强，该方案在HTTPS,SNI以及设置Cookie等场景均适用。规避了证书校验，域名检查等环节
```

**IOS端**:
基于NSURLProtocol可拦截iOS系统上基于上层网络库NSURLConnection/NSURLSession发出的网络请求；

通过以下接口注册自定义NSURLProtocol，用于拦截上层网络请求，并创建新的网络请求接管数据发送、接收、重定向等处理逻辑，将结果反馈给原始请求。

```java
[NSURLProtocol registerClass:[CustomProtocol class]];
```

自定义NSURLProtocol处理过程概述：

- 在canInitWithRequest中过滤要需要做HTTPDNS域名解析的请求；
- 请求拦截后，做HTTPDNS域名解析；
- 解析完成后，同普通请求一样，替换URL.host字段，替换HTTP Header Host域，并接管该请求的数据发送、接收、重定向等处理；

#### 接入流程

##### 服务开通

HTTPDNS是移动研发平台提供的服务，请参考[EMAS 快速入门](https://help.aliyun.com/document_detail/169962.html)开通服务。

##### Android SDK 接入

1. 在项目根目录下的build.gradle文件中添加Maven仓库地址

   ```java
   allprojects {
      repositories {
         maven {
               url 'http://maven.aliyun.com/nexus/content/repositories/releases/'
         }
      }
   }
   ```

2. 在需要引入HTTPDNS服务的模块下的build.gradle中添加依赖

   ```java
   dependencies {
      compile ('com.aliyun.ams:alicloud-android-httpdns:1.3.3@aar') {
         transitive true
      }
   }
   ```

按照以上官方文档配置，在同步工程后，会报错

```shell
Could not find com.aliyun.ams:alicloud-android-utdid:1.1.5.4.
Searched in the following locations:
  - http://maven.aliyun.com/nexus/content/repositories/releases/com/aliyun/ams/alicloud-android-utdid/1.1.5.4/alicloud-android-utdid-1.1.5.4.pom
  - https://dl.google.com/dl/android/maven2/com/aliyun/ams/alicloud-android-utdid/1.1.5.4/alicloud-android-utdid-1.1.5.4.pom
  - https://jcenter.bintray.com/com/aliyun/ams/alicloud-android-utdid/1.1.5.4/alicloud-android-utdid-1.1.5.4.pom
Required by:
    project :app > com.aliyun.ams:alicloud-android-httpdns:1.3.3 > com.aliyun.ams:alicloud-android-beacon:1.0.4.3
```

修改如下

```java
implementation('com.aliyun.ams:alicloud-android-httpdns:1.3.3@aar') {
    transitive true
    exclude group: 'com.aliyun.ams', module: 'alicloud-android-utdid'
}
implementation 'com.aliyun.ams:alicloud-android-utdid:1.1.5.3'
```

1. 引入Retrofit及gson

   增加依赖

   ```java
   implementation 'com.squareup.retrofit2:retrofit:2.3.0'
   implementation 'com.squareup.retrofit2:converter-gson:2.3.0'
   implementation 'com.google.code.gson:gson:2.8.6'
   ```

2. 配置DNS

新建一个类，继承Dns

   ```java
   public class AliDns implements Dns {
   
      private HttpDnsService httpDns;
   
      public AliDns(Context context) {
         //传入account_id，account_id为HTTPDNS控制台添加应用时生成的
         httpDns = HttpDns.getService(context, "account_id");
      }
   
      @Override
      public List<InetAddress> lookup(String hostname) throws UnknownHostException {
         //通过异步解析接口获取ip
         String ip = httpDns.getIpByHostAsync(hostname);
         //Android9.0系统及以后版本，https请求无法直接访问，方便起见，直接在AndroidManifest.xml中配置android:usesCleartextTraffic="true"
         if (ip != null) {
               //如果ip不为null，直接使用该ip进行网络请求
               Log.e("AliDns", "ip:" + ip);
               List<InetAddress> inetAddresses = Arrays.asList(InetAddress.getAllByName(ip));
               return inetAddresses;
         }
         //如果返回null，走系统DNS服务解析域名
         return Dns.SYSTEM.lookup(hostname);
      }
   }
   ```

   设置OkHttpClient的dns

   ```java
   OkHttpClient client = new OkHttpClient.Builder().dns(new AliDns(getApplicationContext())).build();
   ```

3. 调用请求

```java
Retrofit retrofit = new Retrofit.Builder().client(client).baseUrl("域名").addConverterFactory(GsonConverterFactory.create()).build();
Api api = retrofit.create(Api.class);
Call<Bean> call = api.getBanner();
call.enqueue(new Callback<Bean>() {
    @Override
    public void onResponse(Call<Bean> call, Response<Bean> response) {
        if (!response.isSuccessful()) {
            tv.setText("请求失败，错误码:" + response.code());
            return;
    	}
        Bean bean = response.body();
        tv.setText(bean.toString());
    }
 
    @Override
    public void onFailure(Call<Bean> call, Throwable t) {
    	tv.setText(t.getMessage());
    }
});
```

[源码](https://github.com/milovetingting/Samples)
